## Create environment used to hold "global" data used by various package
## functions
.mpi.env <- new.env(parent=emptyenv())

#' Test function level 1
#' @export fun1
fun1 <- function (num.sim=10, num.per=8, num.day=5, ...) {
    final.results <- data.frame (foreach::`%dopar%`(
        foreach::`%:%`(foreach::foreach(j = 1:num.sim,
                                        .combine = cbind,
                                        .packages= 'toymod4'),
                       foreach::foreach (i = 1:num.per,
                                         .packages = 'toymod4',
                                         .combine=rbind)), {
            out3 <- replicate(num.day, fun2())
            out2 <- data.frame(mean(out3))
        }
    )
    )
    ## save outputs for subsequent analyses if required
    saveRDS(final.results, file = paste(num.day ,"_", num.per, "_", num.sim, "_",
                                        format(Sys.time(), "%d_%m_%Y"),
                                        ".rds", sep=""))
    return(final.results)
}

#' Test function level 2
#' @export fun2
fun2 <- function () {
    ## var21 <- get('var21', pos = .mpi.env)
    ## get('var22', pos = .mpi.env)
    ## get('fun22on', pos = .mpi.env)    
    out21 <- ifelse (rpois(1, get('var21', pos = .mpi.env)) > 0,
                     get('var22', pos = .mpi.env) * fun3(),
                     0)
    out22 <- ifelse ( get('fun22on', pos = .mpi.env),
                     fun3(),
                     0)
    out2 <- out21 + out22
}

#' Test function level 3
#' @export fun3
fun3 <- function () {
    ## get('var31', pos = .mpi.env)
    ## get('fun3on', pos = .mpi.env)
    out31 <- ifelse (get('fun3on', pos = .mpi.env),
                     get('var31', pos = .mpi.env),
                     1)
    out32 <- ifelse (get('fun3on', pos = .mpi.env),
                     fun4(),
                     0)
    out3 <- out31 + out32
}

#' Test function level 4
#' @export fun4
fun4 <- function () {
    ## get('var41', pos = .mpi.env)
    ## get('fun4on', pos = .mpi.env)
    out4 <- ifelse (get('fun4on', pos = .mpi.env),
                    get('var41', pos = .mpi.env),
                    1)
}


## Assign values to variables in ".mpi.env" in the local R session
#' local regular arguments localregargs function
#' @export localregargs
localregargs <- function(var21, var22, fun22on, var31, fun3on, var41,
                                                  fun4on) {
    assign('var21', var21, pos = .mpi.env)
    assign('var22', var22, pos = .mpi.env)
    assign('fun22on', fun22on, pos = .mpi.env)
    assign('var31', var31, pos = .mpi.env)
    assign('fun3on', fun3on, pos = .mpi.env)
    assign('var41', var41, pos = .mpi.env)
    assign('fun4on', fun4on, pos = .mpi.env)    
    invisible(NULL)
}

## Register values of "var21", "var22".... It does that by calling localregargs
## directly and in a foreach loop. Calling it directly is necessary when the
## workers are forked, and calling it in a foreach loop is necessary when the
## workers are started via makeCluster or startMPIcluster.  Using both
## mechanisms keeps them consistent and avoids the problem of figuring out which
## mechanism is necessary.
#' regular arguments regargs function
#' @export regargs
regargs <- function(var21, var22, fun22on, var31, fun3on, var41,
                         fun4on) {
  ## Necessary for doMC and doParallelMC.
  ## Doesn't hurt for doParallelSNOW and doMPI.
  localregargs(var21, var22, fun22on, var31, fun3on, var41, fun4on)

  ## Necessary for doParallelSNOW and doMPI.
  ## Doesn't hurt for doMC and doParallelMC.
  foreach(seq_len(getDoParWorkers()), .packages='toymod4') %dopar% {
    localregargs(var21, var22, fun22on, var31, fun3on, var41, fun4on)
  }
  invisible(NULL)
}
